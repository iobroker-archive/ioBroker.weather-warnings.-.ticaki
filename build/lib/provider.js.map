{
  "version": 3,
  "sources": ["../../src/lib/provider.ts"],
  "sourcesContent": ["// Provider\n\nimport type WeatherWarnings from '../main';\nimport * as definitionen from './def/definition';\nimport type { Library } from './library';\nimport { BaseClass } from './library';\nimport type * as providerDef from './def/provider-def';\nimport { MessagesClass } from './messages';\nimport * as NotificationClass from './notification';\nimport { getTestData } from './test-warnings';\nimport * as NotificationType from './def/notificationService-def';\nimport * as messagesDef from './def/messages-def';\nexport const DIV = '-';\n\ntype ProviderOptionsTypeInternal = {\n    service: providerDef.providerServices;\n    warncellId: string | [string, string];\n} & (StringProviderOptionsType | CoordinateProviderOptionsType);\n\ntype ProviderOptionsType = ProviderOptionsTypeInternal;\n\ntype StringProviderOptionsType = BaseProviderOptionsType & {\n    warncellId: string;\n};\ntype CoordinateProviderOptionsType = BaseProviderOptionsType & {\n    warncellId: [string, string];\n};\ntype BaseProviderOptionsType = {\n    providerController: ProviderController;\n    language: string;\n    filter: providerDef.messageFilterType;\n    customName: string;\n};\n\n/** Base class for every provider */\nexport class BaseProvider extends BaseClass {\n    service: providerDef.providerServices;\n    url: string = '';\n    warncellId: string | Array<string> = '';\n    rawData: providerDef.DataImportType = null;\n    library: Library;\n    messages: MessagesClass[] = [];\n    noMessage: MessagesClass;\n    providerController: ProviderController;\n    filter: providerDef.messageFilterType;\n    customName: string = '';\n    warncellIdString: string;\n\n    /**\n     * Initializes the provider.\n     *\n     * @param adapter The adapter instance.\n     * @param options The options for the provider.\n     * @param name The name of the provider.\n     */\n    constructor(adapter: WeatherWarnings, options: ProviderOptionsTypeInternal, name: string) {\n        let warncell =\n            typeof options.warncellId == 'object' && Array.isArray(options.warncellId)\n                ? options.warncellId.join(DIV)\n                : options.warncellId;\n        warncell = warncell.replaceAll('.', '_');\n        super(adapter, 'provider.' + `${name}.${warncell}`);\n\n        this.warncellIdString = warncell;\n        this.service = options.service;\n        this.library = this.adapter.library;\n        this.providerController = options.providerController;\n        this.setService(options.service);\n        this.log.setLogPrefix(`${name}-${options.warncellId as string}`);\n        this.filter = options.filter;\n        this.customName = options.customName;\n\n        this.noMessage = new MessagesClass(this.adapter, 'noMessage', null, {}, this.providerController, this);\n        this.noMessage.updateFormated().catch(() => {});\n        const temp = this.library.cloneGenericObject(\n            //@ts-expect-error ist vorhanden\n            definitionen.statesObjectsWarnings[this.service]._channel,\n        ) as ioBroker.DeviceObject;\n        temp.common.name = name.toUpperCase();\n        this.library.writedp(`provider.${name}`, undefined, temp).catch(() => {});\n\n        this.init().catch(() => {});\n    }\n    /**\n     * Initializes the provider.\n     *\n     * Writes the channel and device objects, and sets the connection status to false.\n     *\n     * @returns A promise that resolves when initialization is complete.\n     */\n    async init(): Promise<void> {\n        const temp = this.library.cloneGenericObject(definitionen.defaultChannel) as ioBroker.ChannelObject;\n        temp.common.name = this.customName;\n        await this.library.writedp(`${this.name}`, undefined, temp);\n        await this.adapter.extendObjectAsync(`${this.name}`, {\n            common: { name: this.customName },\n        });\n\n        await this.library.writedp(`${this.name}.info`, undefined, definitionen.genericStateObjects.info._channel);\n        await this.library.writedp(\n            `${this.name}.formatedKeys`,\n            undefined,\n            definitionen.genericStateObjects.formatedKeysDevice,\n        );\n\n        this.setConnected(false).catch(() => {});\n    }\n\n    /**\n     * Deletes the provider.\n     *\n     * Calls the parent's delete function, deletes all messages, and sets the connection status to false.\n     *\n     * @returns A promise that resolves when deletion is complete.\n     */\n    async delete(): Promise<void> {\n        await super.delete();\n        this.rawData = null;\n        await this.library.memberDeleteAsync(this.messages);\n        this.messages = [];\n        await this.setConnected(false);\n    }\n\n    /**\n     * Returns the provider service of the provider.\n     *\n     * @throws if service is invalid\n     * @returns the provider service\n     */\n    getService(): providerDef.providerServices {\n        if (!this.service) {\n            throw new Error(`baseProvider.getService service is ${this.service == '' ? `''` : `undefined`}`);\n        }\n        return this.service;\n    }\n    /*getStatesObjectsWarnings(key: string): { [key: string]: ioBroker.Object } {\n        return statesObjectsWarnings[this.service][key];\n    }*/\n\n    /**\n     * @param service providerDef.providerServices to set\n     * @returns true on success\n     * @throws if service is invalid\n     * @description Sets the provider service. Checks if service is valid.\n     */\n    setService(service: providerDef.providerServices): boolean {\n        if (\n            !service ||\n            ['dwdService', 'zamgService', 'uwzService', 'ninaService', 'metroService'].indexOf(service) === -1\n        ) {\n            throw new Error(`baseProvider.setService service ${service} is unknowed!`);\n        }\n        this.service = service;\n        return true;\n    }\n\n    /**\n     * Returns the URL for the provider, replacing placeholders with keys.\n     * If `url` is not given, the default URL for the provider is used.\n     * The placeholder is '#  #' and is replaced with each key in `keys`.\n     * The placeholder is then changed to '#+# #'#'.\n     *\n     * @param url the URL to use (default is the default URL for the provider)\n     * @param keys the keys to replace in the URL\n     * @param service the provider service\n     * @returns the resulting URL\n     */\n    static getUrl(url: string = '', keys: string[], service: keyof typeof definitionen.PROVIDER_OPTIONS): string {\n        let result = '';\n        if (!url) {\n            result = definitionen.PROVIDER_OPTIONS[service].url;\n        } else {\n            result = url;\n        }\n        let placeholder = '#  #';\n        for (const k of keys) {\n            result = result.replace(placeholder, k);\n            placeholder = `${placeholder.slice(0, 1)}+${placeholder.slice(1, -1)}+${placeholder.slice(-1)}`;\n        }\n        return result;\n    }\n    /**\n     * Set the connection status for the provider.\n     *\n     * @param status - the status to set\n     * @returns a promise that resolves when the status is set\n     */\n    async setConnected(status: boolean): Promise<void> {\n        this.providerController.connection = this.providerController.connection || status;\n        await this.library.writedp(\n            `${this.name}.info.connection`,\n            !!status,\n            definitionen.genericStateObjects.info.connection,\n        );\n    }\n\n    /**\n     * Write the alerts to statesObjectsWarnings and returns the alerts as a\n     * genericWarntypeAlertJsonType.\n     *\n     * @param allReplys - the alerts to write, if not given, a new one is created\n     * @returns the alerts as a genericWarntypeAlertJsonType\n     * @throws if error occurs\n     */\n    async getAlertsAndWrite(\n        allReplys: messagesDef.genericWarntypeAlertJsonType | undefined = undefined,\n    ): Promise<messagesDef.genericWarntypeAlertJsonType> {\n        const reply: any = { asList: '' };\n        for (const t in messagesDef.genericWarntyp) {\n            if (t == '0') {\n                continue;\n            }\n            reply[messagesDef.genericWarntyp[Number(t) as keyof messagesDef.genericWarntypeType].id] = {\n                level: -1,\n                start: 1,\n                end: 1,\n                headline: '',\n                active: false,\n                type: -1,\n            };\n        }\n        if (!reply) {\n            throw new Error('error(234) reply not definied');\n        }\n        if (allReplys === undefined) {\n            allReplys = JSON.parse(JSON.stringify(reply));\n        }\n        [reply, allReplys].forEach(reply => {\n            let warntypeArray: string[] = [];\n            for (const m of this.messages) {\n                if (!m) {\n                    continue;\n                }\n                const name = messagesDef.genericWarntyp[m.genericType].id;\n                if (name == 'none') {\n                    continue;\n                }\n                if (reply[name] === undefined) {\n                    continue;\n                }\n                if (m.endtime < Date.now()) {\n                    continue;\n                }\n\n                if (\n                    (m.starttime <= Date.now() && reply[name].level < m.level) ||\n                    (m.starttime > Date.now() && (reply[name].start === 1 || reply[name].start > m.starttime))\n                ) {\n                    warntypeArray.push(this.library.getTranslation(messagesDef.genericWarntyp[m.genericType].name));\n                    reply[name] = {\n                        level: m.level,\n                        start: m.starttime,\n                        end: m.endtime,\n                        headline: m.formatedData !== undefined ? String(m.formatedData.headline) : '',\n                        active: m.starttime <= Date.now() && m.endtime >= Date.now(),\n                        type: m.genericType,\n                    };\n                    if (reply === allReplys) {\n                        reply[name].provider = m.formatedData ? m.formatedData.provider : '';\n                    }\n                }\n            }\n            if (reply.asList !== undefined) {\n                warntypeArray = warntypeArray.concat(reply.asList.split(', '));\n            }\n            reply.asList = warntypeArray.filter((item, pos, arr) => item && arr.indexOf(item) == pos).join(', ');\n        });\n        await this.library.writeFromJson(\n            `${this.name}.alerts`,\n            'allService.alerts',\n            definitionen.statesObjectsWarnings,\n            reply,\n            false,\n        );\n\n        return allReplys!;\n    }\n\n    /**\n     * Downloads data from the selected provider.\n     *\n     * Downloads data from the provider selected via service and warncellId.\n     * If useTestWarnings is set, test data will be returned.\n     * If the provider is unavailable, errors will be logged and the function will return null.\n     * If the provider does not send data, the lastUpdate state will not be updated.\n     *\n     * @returns  The data from the provider as a generic object.\n     */\n    async getDataFromProvider(): Promise<providerDef.DataImportType> {\n        if (!this.url || !this.warncellId) {\n            this.log.debug(\n                `Warn (31) this.url: ${this.url} this.warncellid: ${this.warncellId as string} this.service: ${this.getService()}`,\n            );\n        }\n        try {\n            if (this.unload) {\n                return;\n            }\n\n            // show test mode in Info states\n            await this.library.writedp(\n                `${this.name}.info.testMode`,\n                this.adapter.config.useTestWarnings,\n                definitionen.genericStateObjects.info.testMode,\n            );\n            if (this.adapter.config.useTestWarnings) {\n                return this.library.cloneGenericObject(\n                    getTestData(this.service, this.adapter) as object,\n                ) as providerDef.DataImportType;\n            }\n            const result = await this.adapter.fetch(this.url, undefined, 300_000);\n            if (!result) {\n                this.log.warn(`Warn(20) no data for ${this.getService()} from ${this.url}`);\n                return null;\n            }\n            if (this.unload) {\n                return null;\n            }\n            await this.setConnected(true);\n\n            await this.library.writedp(\n                `${this.name}.warning.warning_json`,\n                JSON.stringify(result),\n                definitionen.genericStateObjects.warnings_json,\n            );\n            if (this.adapter.config.useJsonHistory) {\n                const dp = `${this.name}.warning.jsonHistory`;\n                const state = this.library.readdp(dp);\n                let history: object[] = [];\n                if (state && state.val && typeof state.val == 'string') {\n                    history = JSON.parse(state.val);\n                }\n                history.unshift(result);\n                await this.library.writedp(dp, JSON.stringify(history), definitionen.genericStateObjects.jsonHistory);\n            }\n            await this.library.writedp(\n                `${this.name}.lastUpdate`,\n                Date.now(),\n                definitionen.genericStateObjects.lastUpdate,\n            );\n            return result as any;\n        } catch (error) {\n            this.adapter.handleFetchError(error);\n        }\n        await this.setConnected(false);\n        return null;\n    }\n\n    /**\n     * after updating data, this function sorts the messages, deletes the messages that send a remove with a follow up and\n     * writes the formated keys to the states.\n     */\n    async finishUpdateData(): Promise<void> {\n        let index = -1;\n        this.messages.sort((a, b) => {\n            return a.starttime - b.starttime;\n        });\n        // delete msgs that send a remove with a follow up\n        this.messages = this.messages.filter(item => {\n            if (item.notDeleted || item.newMessage) {\n                return true;\n            }\n            if (item.endtime > Date.now()) {\n                return true;\n            }\n            for (const innerItem of this.messages) {\n                if (innerItem == item || innerItem.provider !== item.provider || innerItem.type !== item.type) {\n                    continue;\n                }\n                const diff = Math.abs(innerItem.starttime - item.endtime);\n                if (diff <= this.providerController.refreshTime || innerItem.starttime <= item.endtime) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        for (let m = 0; m < this.messages.length && m < this.adapter.config.numOfRawWarnings; m++) {\n            index = m;\n            await this.messages[m].writeFormatedKeys(m);\n        }\n        for (index++; index < this.adapter.config.numOfRawWarnings; index++) {\n            await this.noMessage.writeFormatedKeys(index);\n        }\n        await this.library.garbageColleting(\n            `${this.name}.formatedKeys`,\n            (this.providerController.refreshTime || 600_000) / 2,\n        );\n        await this.library.garbageColleting(\n            `${this.name}.warning`,\n            (this.providerController.refreshTime || 600_000) / 2,\n        );\n    }\n\n    /**\n     * Writes the raw warning data to the states.\n     *\n     * @param data - raw warning data\n     * @param counter - counter of the raw warning\n     */\n    async updateData(data: any, counter: number): Promise<void> {\n        if (!data) {\n            return;\n        }\n        await this.library.writedp(`${this.name}.warning`, undefined, definitionen.genericStateObjects.warningDevice);\n        await this.library.writeFromJson(\n            `${this.name}.warning.${`00${counter.toString()}`.slice(-2)}`,\n            `${this.service}.raw`,\n            definitionen.statesObjectsWarnings,\n            data,\n        );\n    }\n    /** Remove marked Messages. */\n    clearMessages(): void {\n        for (let m = 0; m < this.messages.length; m++) {\n            this.messages[m].newMessage = false;\n            if (this.messages[m].notDeleted == false) {\n                this.log.debug('Remove a warning from db.');\n                this.messages.splice(Number(m--), 1);\n            }\n        }\n    }\n    /**\n     * Called at the end of a turn.\n     *\n     * Writes the summary warning data to the states.\n     *\n     * @returns A Promise that resolves when the data has been written.\n     */\n    async finishTurn(): Promise<void> {\n        await this.adapter.library.writedp(\n            `${this.name}.summary`,\n            undefined,\n            definitionen.genericStateObjects.summary._channel,\n        );\n        await this.adapter.library.writedp(\n            `${this.name}.summary.warntypes`,\n            this.messages.map(a => (a.formatedData ? a.formatedData.warntypegenericname : '')).join(', '),\n            definitionen.genericStateObjects.summary.warntypes,\n        );\n        await this.library.garbageColleting(`${this.name}.activeWarnings_json`, 15_000);\n    }\n}\n\n/**\n * Represents a DWD provider.\n *\n * This class extends the [BaseProvider](cci:2://file:///home/tim/ioBroker.weather-warnings/src/lib/provider.ts:37:0-454:1) class and provides specific functionality for the DWD provider.\n */\nexport class DWDProvider extends BaseProvider {\n    /**\n     * Initializes the DWD provider.\n     *\n     * @param adapter The adapter instance.\n     * @param options The options for the provider.\n     */\n    constructor(adapter: WeatherWarnings, options: StringProviderOptionsType) {\n        super(adapter, { ...options, service: 'dwdService' }, `dwd`);\n        this.warncellId = options.warncellId;\n        const url =\n            definitionen.PROVIDER_OPTIONS.dwdService.url_base +\n            (this.warncellId.startsWith('9') || this.warncellId.startsWith('10')\n                ? definitionen.PROVIDER_OPTIONS.dwdService.url_appendix_land\n                : definitionen.PROVIDER_OPTIONS.dwdService.url_appendix_town) +\n            definitionen.PROVIDER_OPTIONS.dwdService.url_language;\n        this.url = DWDProvider.getUrl(url, [this.warncellId, options.language], this.service);\n    }\n    /**\n     * Retrieves the data from the DWD provider and updates the messages array.\n     *\n     * @returns A Promise that resolves when the data has been written.\n     */\n    async updateData(): Promise<void> {\n        const result = (await this.getDataFromProvider()) as providerDef.dataImportDwdType;\n        if (!result) {\n            return;\n        }\n        this.log.debug(`Got ${result.features.length} warnings from server`);\n        result.features.sort((a, b) => {\n            return new Date(a.properties.ONSET).getTime() - new Date(b.properties.ONSET).getTime();\n        });\n        this.messages.forEach(a => (a.notDeleted = false));\n        for (let a = 0; a < this.adapter.config.numOfRawWarnings && a < result.features.length; a++) {\n            const w = result.features[a];\n            if (w.properties.STATUS == 'Test') {\n                continue;\n            }\n            if (\n                this.filter.hours > 0 &&\n                new Date(w.properties.ONSET).getTime() > Date.now() + this.filter.hours * 3_600_000\n            ) {\n                continue;\n            }\n            await super.updateData(w.properties, a);\n\n            /**\n             * filter messages dwd\n             */\n            const index = this.messages.findIndex(m => m.rawWarning.IDENTIFIER == w.properties.IDENTIFIER);\n\n            if (index == -1) {\n                const nmessage = new MessagesClass(\n                    this.adapter,\n                    'dwd-msg',\n                    this,\n                    w.properties,\n                    this.providerController,\n                );\n                await nmessage.updateFormated();\n\n                if (nmessage && nmessage.filter(this.filter)) {\n                    this.messages.push(nmessage);\n                }\n            } else {\n                await this.messages[index].updateData(w.properties);\n            }\n        }\n        for (let n = 0; n < this.messages.length; n++) {\n            const newmsg = this.messages[n];\n            if (!newmsg.newMessage) {\n                continue;\n            }\n            for (let o = 0; o < this.messages.length; o++) {\n                const oldmsg = this.messages[o];\n                if (oldmsg.newMessage) {\n                    continue;\n                }\n                if (oldmsg.formatedData === undefined || newmsg.formatedData === undefined) {\n                    continue;\n                }\n                if (oldmsg.rawWarning.EC_II != newmsg.rawWarning.EC_II) {\n                    continue;\n                }\n                if (oldmsg.starttime > newmsg.endtime || newmsg.starttime > oldmsg.endtime) {\n                    continue;\n                }\n                newmsg.silentUpdate();\n                this.log.debug('Remove a old warning.(Silent Update)');\n                if (o <= n) {\n                    n--;\n                }\n                this.messages.splice(o--, 1);\n                break;\n            }\n        }\n        await this.finishUpdateData();\n    }\n}\n\n/**\n * Represents a ZAMG provider.\n *\n * This class extends the BaseProvider class and provides specific functionality for the ZAMG provider.\n */\nexport class ZAMGProvider extends BaseProvider {\n    /**\n     * Initializes a new instance of the ZAMGProvider class.\n     *\n     * @param adapter The WeatherWarnings adapter instance.\n     * @param options The options for configuring the ZAMG provider, including warncellId and language.\n     */\n    constructor(adapter: WeatherWarnings, options: CoordinateProviderOptionsType) {\n        super(adapter, { ...options, service: 'zamgService' }, `zamg`);\n        this.warncellId = options.warncellId;\n        this.url = ZAMGProvider.getUrl('', [this.warncellId[0], this.warncellId[1], options.language], this.service);\n    }\n\n    /**\n     * Updates the data for the ZAMG provider.\n     *\n     * Retrieves the data from the ZAMG server and updates the messages.\n     * If the filter is set to only show warnings in the next X hours, ignores the warnings that are outside of this time frame.\n     * Also ignores warnings that are already expired.\n     *\n     * @returns A promise that resolves when the update is complete.\n     */\n    async updateData(): Promise<void> {\n        const result = (await this.getDataFromProvider()) as providerDef.dataImportZamgType;\n        if (!result) {\n            return;\n        }\n\n        if (!result.properties || !result.properties.warnings) {\n            this.log.debug(`Got 0 warnings from server`);\n            return;\n        }\n        this.log.debug(`Got ${result.properties.warnings.length} warnings from server`);\n        result.properties.warnings.sort((a, b) => {\n            return Number(a.properties.rawinfo.start) - Number(b.properties.rawinfo.start);\n        });\n        this.messages.forEach(a => (a.notDeleted = false));\n        let b = 0;\n        for (let a = 0; b < this.adapter.config.numOfRawWarnings && a < result.properties.warnings.length; a++) {\n            if (\n                this.filter.hours > 0 &&\n                Number(result.properties.warnings[a].properties.rawinfo.start) >\n                    Date.now() / 1000 + this.filter.hours * 3600\n            ) {\n                continue;\n            }\n            if (Number(result.properties.warnings[a].properties.rawinfo.end) < Date.now() / 1000) {\n                continue;\n            }\n            b++;\n            // special case for zamg\n            result.properties.warnings[a].properties.location = result.properties.location.properties.name;\n            result.properties.warnings[a].properties.nachrichtentyp = result.properties.warnings[a].type;\n            await super.updateData(result.properties.warnings[a].properties, a);\n            const index = this.messages.findIndex(m => {\n                return (\n                    m.rawWarning.warnid == result.properties.warnings[a].properties.warnid &&\n                    result.properties.warnings[a].properties.rawinfo.wlevel == m.rawWarning.rawinfo.wlevel &&\n                    result.properties.warnings[a].properties.rawinfo.wtype == m.rawWarning.rawinfo.wtype &&\n                    result.properties.warnings[a].properties.rawinfo.start == m.rawWarning.rawinfo.start\n                );\n            });\n            if (index == -1) {\n                const nmessage = new MessagesClass(\n                    this.adapter,\n                    'zamg-msg',\n                    this,\n                    result.properties.warnings[a].properties,\n                    this.providerController,\n                );\n                await nmessage.updateFormated();\n                if (nmessage && nmessage.filter(this.filter)) {\n                    this.messages.push(nmessage);\n                }\n            } else {\n                await this.messages[index].updateData(result.properties.warnings[a].properties);\n            }\n        }\n        await this.finishUpdateData();\n    }\n}\n\n/**\n * Represents a UWZ provider.\n *\n * This class extends the BaseProvider class and provides specific functionality for the UWZ provider.\n */\nexport class UWZProvider extends BaseProvider {\n    /**\n     * Initializes the UWZ provider.\n     *\n     * @param adapter The adapter instance.\n     * @param options The options for the provider.\n     */\n    constructor(adapter: WeatherWarnings, options: StringProviderOptionsType) {\n        super(adapter, { ...options, service: 'uwzService' }, `uwz`);\n        this.warncellId = options.warncellId.toUpperCase();\n        this.url = BaseProvider.getUrl('', [this.warncellId, options.language], this.service);\n    }\n\n    /**\n     * Gets the warncell for the given warncellId.\n     *\n     * The warncell is retrieved by querying the UWZ provider's API.\n     *\n     * @param warncellId The warncellId to retrieve the warncell for.\n     * @param service The service to use for retrieving the warncell.\n     * @param that The WeatherWarnings instance to use for logging errors.\n     * @returns The warncell for the given warncellId, or an empty string if no valid warncell could be found.\n     */\n    static async getWarncell(\n        warncellId: [string, string],\n        service: providerDef.providerServices,\n        that: WeatherWarnings,\n    ): Promise<string> {\n        try {\n            const result = (await that.fetch(\n                UWZProvider.getUrl(\n                    definitionen.PROVIDER_OPTIONS.uwzService.warncellUrl,\n                    [warncellId[0], warncellId[1]],\n                    service,\n                ),\n            )) as any;\n            if (result) {\n                if (result && result[0]) {\n                    return result[0].AREA_ID;\n                }\n            }\n            that.log.error(`No valid warncell found for ${JSON.stringify(warncellId)}`);\n        } catch (error: any) {\n            that.handleFetchError(error);\n        }\n        return '';\n    }\n    /**\n     * Updates the data for the UWZ provider.\n     *\n     * Retrieves the data from the UWZ server and updates the messages.\n     * If the filter is set to only show warnings in the next X hours, ignores the warnings that are outside of this time frame.\n     * Also ignores warnings that are already expired.\n     *\n     * @returns A promise that resolves when the update is complete.\n     */\n    async updateData(): Promise<void> {\n        const result = (await this.getDataFromProvider()) as providerDef.dataImportUWZType;\n        if (!result || !result.results || result.results == null) {\n            this.log.warn('Invalid result from uwz server!');\n            return;\n        }\n        result.results.sort((a, b) => {\n            if (a && b && a.dtgStart && b.dtgStart) {\n                return a.dtgStart - b.dtgStart;\n            }\n            return 0;\n        });\n        this.messages.forEach(a => (a.notDeleted = false));\n        for (let a = 0; a < this.adapter.config.numOfRawWarnings && a < result.results.length; a++) {\n            if (result.results[a] == null) {\n                continue;\n            }\n            if (this.filter.hours > 0 && result.results[a].dtgStart > Date.now() / 1000 + this.filter.hours * 3600) {\n                continue;\n            }\n            await super.updateData(result.results[a], a);\n\n            const index = this.messages.findIndex(m => m.rawWarning.payload.id == result.results[a].payload.id);\n            if (index == -1) {\n                const nmessage = new MessagesClass(\n                    this.adapter,\n                    'uwz-msg',\n                    this,\n                    result.results[a],\n                    this.providerController,\n                );\n                await nmessage.updateFormated();\n                if (nmessage && nmessage.filter(this.filter)) {\n                    this.messages.push(nmessage);\n                }\n            } else {\n                await this.messages[index].updateData(result.results[a]);\n            }\n        }\n        this.log.debug(`Got ${result.results.length} warnings from server`);\n\n        await this.finishUpdateData();\n    }\n}\n\n/**\n * Represents a NINA provider.\n *\n * This class extends the BaseProvider class and provides specific functionality for the NINA provider.\n */\nexport class NINAProvider extends BaseProvider {\n    /**\n     * Initializes a new instance of the NINAProvider class.\n     *\n     * @param adapter The WeatherWarnings adapter instance.\n     * @param options The options for the provider.\n     */\n    constructor(adapter: WeatherWarnings, options: CoordinateProviderOptionsType) {\n        super(adapter, { ...options, service: 'ninaService' }, `nina`);\n    }\n}\n\n/**\n * Represents a METRO provider.\n *\n * This class extends the BaseProvider class and provides specific functionality for the METRO provider.\n */\nexport class METROProvider extends BaseProvider {\n    /**\n     * Initializes a new instance of the METROProvider class.\n     *\n     * @param adapter The WeatherWarnings adapter instance.\n     * @param options The options for the provider.\n     */\n    constructor(adapter: WeatherWarnings, options: CoordinateProviderOptionsType) {\n        super(adapter, { ...options, service: 'metroService' }, `nina`);\n    }\n}\n/**\n * Represents a provider controller.\n *\n * This class extends the BaseClass and provides functionality for managing providers.\n */\nexport class ProviderController extends BaseClass {\n    providers: providerDef.ProviderClassType[] = [];\n    notificationServices: NotificationClass.NotificationClass[] = [];\n    noWarning: MessagesClass;\n\n    refreshTimeRef: ioBroker.Timeout | undefined = undefined;\n    alertTimeoutRef: ioBroker.Timeout | undefined = undefined;\n\n    connection = true;\n    name = 'provider';\n    refreshTime: number = 300_000;\n    library: Library;\n    pushOn = false;\n    //globalSpeakSilentTime: ({ profil: string; day: number[]; start: number; end: number } | null)[] = [];\n    testStatus = 0;\n    activeMessages = 0;\n    silentTime: {\n        shouldSpeakAllowed?: boolean;\n        forceOff: boolean;\n        profil: providerDef.silentTimeConfigType[][];\n    } = {\n        forceOff: false,\n        profil: [],\n    };\n    /**\n     * Initializes a new instance of the ProviderController class.\n     *\n     * @param adapter The WeatherWarnings adapter instance.\n     */\n    constructor(adapter: WeatherWarnings) {\n        super(adapter, 'provider');\n        this.library = this.adapter.library;\n        this.noWarning = new MessagesClass(this.adapter, 'noMessage', null, {}, this);\n        this.noWarning.newMessage = false;\n        this.noWarning.notDeleted = false;\n        this.doEndOfUpdater.bind(this);\n    }\n    /**\n     * Initializes the provider controller.\n     *\n     * Reads the config, sets some states and updates the formated data objects.\n     * Also sets the silent time based on the config.\n     *\n     * @returns A promise that resolves when initialization is complete.\n     */\n    async init(): Promise<void> {\n        this.pushOn = !this.adapter.config.notPushAtStart; // ups wrong variable name PushAtStart\n        this.refreshTime = this.adapter.config.refreshTime * 60_000;\n\n        const typeStates: string[] = [];\n        for (const a in messagesDef.genericWarntyp) {\n            typeStates[parseInt(a)] = this.library.getTranslation(\n                messagesDef.genericWarntyp[a as unknown as keyof messagesDef.genericWarntypeType].name,\n            );\n        }\n        definitionen.statesObjectsWarnings.allService.formatedkeys.warntypegeneric.common.states = typeStates;\n        //update FormatedDataObjects\n        const states = await this.adapter.getStatesAsync('provider.*');\n        for (const state in states) {\n            if (state.includes('.formatedKeys.')) {\n                const key = state\n                    .split('.')\n                    .pop() as keyof typeof definitionen.statesObjectsWarnings.allService.formatedkeys;\n                if (definitionen.statesObjectsWarnings.allService.formatedkeys[key] != undefined) {\n                    const def = definitionen.statesObjectsWarnings.allService.formatedkeys[key];\n                    def.common.name =\n                        typeof def.common.name == 'string'\n                            ? await this.library.getTranslationObj(def.common.name)\n                            : def.common.name;\n                    await this.adapter.extendObjectAsync(\n                        state.replace(`${this.adapter.name}.${this.adapter.instance}.`, ''),\n                        definitionen.statesObjectsWarnings.allService.formatedkeys[key],\n                    );\n                }\n            }\n        }\n\n        const profileNames: string[] = [];\n        if (this.adapter.config.silentTime !== undefined) {\n            for (let p = 0; p < this.adapter.config.silentTime.length; p++) {\n                if (!this.adapter.config.silentTime[p].speakProfile) {\n                    continue;\n                }\n                if (this.adapter.config.silentTime[p].silentTime.length == 0) {\n                    continue;\n                }\n                profileNames.push(this.adapter.config.silentTime[p].speakProfile);\n                this.silentTime.profil.push(\n                    (this.adapter.config.silentTime[p].silentTime || [])\n                        .map((item): providerDef.silentTimeConfigType | null => {\n                            const result: providerDef.silentTimeConfigType = {\n                                day: [],\n                                start: 0,\n                                end: 0,\n                            };\n                            if (\n                                typeof item !== 'object' ||\n                                item === null ||\n                                typeof item.start !== 'string' ||\n                                typeof item.end !== 'string' ||\n                                item.day === null ||\n                                !Array.isArray(item.day) ||\n                                item.day.length == 0\n                            ) {\n                                return null;\n                            }\n                            for (const a in item) {\n                                const b = a as keyof typeof item;\n                                if (b != 'day') {\n                                    const t = item[b].split(':');\n                                    if (Number.isNaN(t[0])) {\n                                        return null;\n                                    }\n                                    if (!Number.isNaN(t[1]) && parseInt(t[1]) > 0) {\n                                        t[1] = String(parseInt(t[1]) / 60);\n                                        item[b] = String(parseFloat(t[0]) + parseFloat(t[1]));\n                                    } else {\n                                        item[b] = t[0];\n                                    }\n                                }\n                                if (b == 'day') {\n                                    result.day = item.day;\n                                } else if (b == 'end') {\n                                    result.end = parseFloat(item.end);\n                                } else {\n                                    result.start = parseFloat(item.start);\n                                }\n                            }\n                            this.log.info(\n                                `Silent time added: Profil: ${this.adapter.config.silentTime[p].speakProfile} start: ${\n                                    result.start\n                                } end: ${result.end} days: ${JSON.stringify(result.day)}`,\n                            );\n                            return result.day.length != 0 && result.start != result.end ? result : null;\n                        })\n                        .filter(f => f != null),\n                );\n            }\n            definitionen.statesObjectsWarnings.allService.commands.silentTime.profil.common.states = profileNames;\n            await this.library.writedp(\n                `commands.silentTime`,\n                undefined,\n                definitionen.statesObjectsWarnings.allService.commands.silentTime._channel,\n            );\n            for (const a in definitionen.actionStates) {\n                const dp = a as keyof typeof definitionen.actionStates;\n                const data = definitionen.actionStates[dp];\n                if (!this.library.readdp(String(dp))) {\n                    await this.library.writedp(String(dp), data.default, data.def);\n                } else {\n                    const def = definitionen.actionStates[dp].def;\n                    const obj = await this.adapter.getObjectAsync(String(dp));\n                    if (obj) {\n                        obj.common = def.common;\n                        await this.adapter.setObjectAsync(String(dp), obj);\n                    }\n                }\n            }\n        }\n\n        /*\n        // this code ist to swap genericWarntyp to ids with a array of warntypes\n        const warntyp = messagesDef.genericWarntyp;\n        const mixedWarntyp: any = {};\n        Object.entries(warntyp).forEach((element) => {\n            mixedWarntyp.dwdService = mixedWarntyp.dwdService || {};\n            mixedWarntyp.uwzService = mixedWarntyp.uwzService || {};\n            mixedWarntyp.zamgService = mixedWarntyp.zamgService || {};\n            element[1].dwdService.forEach(\n                (a) => (mixedWarntyp.dwdService[`${a}`] = [...(mixedWarntyp.dwdService[`${a}`] || []), element[1].id]),\n            );\n            element[1].uwzService.forEach(\n                (a) => (mixedWarntyp.uwzService[`${a}`] = [...(mixedWarntyp.uwzService[`${a}`] || []), element[1].id]),\n            );\n            element[1].zamgService.forEach(\n                (a) =>\n                    (mixedWarntyp.zamgService[`${a}`] = [...(mixedWarntyp.zamgService[`${a}`] || []), element[1].id]),\n            );\n        });\n        const resultWarntyp: any = [];\n        for (const a in mixedWarntyp) {\n            if (!resultWarntyp[a]) resultWarntyp[a] = [];\n            for (const b in mixedWarntyp[a]) {\n                let add = true;\n                for (const c in resultWarntyp) {\n                    if (resultWarntyp[c].type) {\n                        if (\n                            mixedWarntyp[a][b].every((x: any) => resultWarntyp[c].type.includes(x)) &&\n                            resultWarntyp[c].type.every((x: any) => mixedWarntyp[a][b].includes(x))\n                        ) {\n                            add = false;\n                            if (resultWarntyp[c][a] == undefined) resultWarntyp[c][a] = [];\n                            resultWarntyp[c][a].push(b);\n                            break;\n                        }\n                    }\n                }\n                if (add) {\n                    const t: any = { type: mixedWarntyp[a][b] };\n                    t[a] = [b];\n                    resultWarntyp.push(t);\n                }\n            }\n        }\n        const result: any = {};\n        for (const a in resultWarntyp) {\n            if (!resultWarntyp[a].type) continue;\n            result[a] = resultWarntyp[a];\n            result[a].id = resultWarntyp[a].type.join(', ');\n            result[a].name = 'noname';\n            delete result[a].type;\n        }\n        this.log.debug(JSON.stringify(result));*/\n    }\n\n    /**\n     * Create notification services from the given configuration.\n     *\n     * @param optionList A dictionary of notification service configuration options\n     * @returns A promise that resolves when the notification services have been created.\n     */\n    async createNotificationService(optionList: NotificationType.OptionsType): Promise<void> {\n        for (const a in optionList) {\n            const options = optionList[a as keyof NotificationType.OptionsType];\n            if (options === undefined) {\n                return;\n            }\n            let tempAdapters = [options.adapter];\n            if (options.useadapterarray && options.adapters) {\n                tempAdapters = options.adapters;\n            }\n            for (const a of tempAdapters) {\n                options.adapter = a;\n                const objs =\n                    options.adapter != ''\n                        ? await this.adapter.getObjectViewAsync('system', 'instance', {\n                              startkey: `system.adapter.${options.adapter}`,\n                              endkey: `system.adapter.${options.adapter}`,\n                          })\n                        : null;\n                if (!options.useadapter || (objs && objs.rows && objs.rows.length > 0)) {\n                    const noti = new NotificationClass.NotificationClass(\n                        this.adapter,\n                        JSON.parse(JSON.stringify(options)),\n                    );\n                    this.notificationServices.push(noti);\n                    await noti.init();\n                } else {\n                    this.log.error(\n                        `Configuration: ${options.name} is active, ${options.adapter === 'none' ? `but no adapter selected!` : `but dont find ${options.adapter} adapter!`}`,\n                    );\n                    throw new Error(\n                        `Configuration: ${options.name} is active, ${options.adapter === 'none' ? `but no adapter selected` : `but dont find ${options.adapter} adapter!`}`,\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates a new provider instance if it does not already exist.\n     *\n     * Checks the list of existing providers to see if one already exists with the specified\n     * `warncellId` and `service`. If no such provider exists, it creates a new provider\n     * instance based on the specified service type ('dwdService', 'uwzService', 'zamgService', or 'ninaService').\n     *\n     * Throws an error if the `warncellId` type does not match the expected type for the service.\n     *\n     * @param options - The options used to configure the provider, including `warncellId` and `service`.\n     * @returns The newly created provider instance or the existing provider if it already exists.\n     * @throws An error if the service type is not defined or if the `warncellId` type is incorrect.\n     */\n    createProviderIfNotExist(options: ProviderOptionsType): providerDef.ProviderClassType {\n        const index = this.providers.findIndex(\n            p =>\n                p &&\n                ((typeof p.warncellId == 'string' && p.warncellIdString == options.warncellId) ||\n                    (typeof options.warncellId == 'object' && options.warncellId.join(DIV) == p.warncellIdString)) &&\n                p.getService() == options.service,\n        );\n        if (index == -1) {\n            let p: providerDef.ProviderClassType;\n            switch (options.service) {\n                case 'dwdService':\n                    if (Array.isArray(options.warncellId)) {\n                        throw new Error('Error 122 warncellId is a Array');\n                    }\n                    p = new DWDProvider(this.adapter, {\n                        ...options,\n                        warncellId: options.warncellId,\n                        providerController: this,\n                    });\n                    break;\n                case 'uwzService':\n                    if (Array.isArray(options.warncellId)) {\n                        throw new Error('Error 123 warncellId is a Array');\n                    }\n                    p = new UWZProvider(this.adapter, {\n                        ...options,\n                        warncellId: options.warncellId,\n                        providerController: this,\n                    });\n                    break;\n                case 'zamgService':\n                    if (!Array.isArray(options.warncellId)) {\n                        throw new Error('Error 124 warncellId is not an Array');\n                    }\n                    p = new ZAMGProvider(this.adapter, {\n                        ...options,\n                        warncellId: options.warncellId,\n                        providerController: this,\n                    });\n                    break;\n                case 'ninaService':\n                    if (!Array.isArray(options.warncellId)) {\n                        throw new Error('Error 125 warncellId is not an Array');\n                    }\n                    p = new NINAProvider(this.adapter, {\n                        ...options,\n                        warncellId: options.warncellId,\n                        providerController: this,\n                        language: this.adapter.config.dwdLanguage,\n                    });\n                    break;\n                default:\n                    throw new Error('Error 126 service is not defined');\n                //todo add metroServicce\n            }\n            if (p) {\n                this.providers.push(p);\n            }\n            return p;\n        }\n        this.log.error(`Attempt to create an existing provider. ${options.service}`);\n        return this.providers[index];\n    }\n\n    /**\n     * Deletes the provider controller and all of its providers and notification services.\n     *\n     * @returns A promise that resolves when the deletion is complete.\n     */\n    async delete(): Promise<void> {\n        await super.delete();\n        await this.library.memberDeleteAsync(this.providers);\n        await this.library.memberDeleteAsync(this.notificationServices);\n        this.providers = [];\n        this.notificationServices = [];\n        await this.setConnected(false);\n        if (this.refreshTimeRef) {\n            this.adapter.clearTimeout(this.refreshTimeRef);\n        }\n        if (this.alertTimeoutRef) {\n            this.adapter.clearTimeout(this.alertTimeoutRef);\n        }\n    }\n\n    /**\n     * Updates all providers in endless loop.\n     */\n    updateEndless = async (): Promise<void> => {\n        if (this.adapter.config.useTestCase) {\n            if (++this.testStatus > 3) {\n                this.testStatus = 1;\n            }\n            this.adapter.config.useTestWarnings = true;\n            this.refreshTime = 60_000;\n        }\n        this.connection = false;\n        if (this.refreshTimeRef) {\n            this.adapter.clearTimeout(this.refreshTimeRef);\n        }\n        if (this.providers.length == 0) {\n            await this.setConnected(false);\n            return;\n        }\n        if (this.unload) {\n            return;\n        }\n        const tasks: Promise<void>[] = [];\n        for (let index = 0; index < this.providers.length; index++) {\n            if (this.providers[index]) {\n                //@ts-expect-error we dont call base class function\n                tasks.push(this.providers[index].updateData());\n            }\n        }\n        await Promise.all(tasks);\n        await this.doEndOfUpdater();\n        await this.updateAlertEndless(false);\n        this.refreshTimeRef = this.adapter.setTimeout(this.updateEndless, this.refreshTime || 600_000);\n    };\n    /**\n     * Periodically updates alerts in an endless loop.\n     *\n     * This function sets the `speakAllowed` status and checks for alerts.\n     * It avoids updating alerts on exact minute, second, and half-second intervals\n     * by scheduling the next update 1.333 seconds after the last full minute.\n     * If `endless` is true, it continues scheduling updates indefinitely.\n     *\n     * @param endless - A boolean indicating whether to continue updating alerts endlessly.\n     *                  Defaults to true.\n     * @returns A promise that resolves when the alert update is complete.\n     */\n    updateAlertEndless = async (endless: boolean = true): Promise<void> => {\n        if (this.unload) {\n            return;\n        }\n        await this.setSpeakAllowed();\n        await this.checkAlerts();\n        /** update every minute after 1.333 seconds. Avoid the full minute, full second and half second :) */\n        const timeout = 61_333 - (Date.now() % 60_000);\n        if (endless) {\n            this.alertTimeoutRef = this.adapter.setTimeout(this.updateAlertEndless, timeout);\n        }\n    };\n\n    /**\n     * Updates the alerts for all providers.\n     *\n     * Iterates over all providers, calling their `getAlertsAndWrite` method and passing the result to the next provider.\n     * After all providers have been called, it writes the resulting alerts to the `allService.alerts` state.\n     *\n     * @returns A promise that resolves when the alerts have been written.\n     */\n    async checkAlerts(): Promise<void> {\n        let reply = undefined;\n        for (const p of this.providers) {\n            reply = await p.getAlertsAndWrite(reply);\n        }\n        if (reply !== undefined) {\n            await this.library.writeFromJson(\n                'alerts',\n                'allService.alerts',\n                definitionen.statesObjectsWarnings,\n                reply,\n                false,\n            );\n        }\n    }\n\n    /**\n     * Completes the update process for all providers.\n     *\n     * Sets the connection status and counts active messages across all providers.\n     * Writes the number of active warnings to the data points for each provider and the controller.\n     * If push notifications are enabled, sends notifications for new, removed, or all messages.\n     * Clears messages and finishes the turn for each provider.\n     *\n     * @returns A promise that resolves when the update process is complete.\n     */\n    async doEndOfUpdater(): Promise<void> {\n        await this.setConnected();\n        //await this.updateMesssages();\n        this.activeMessages = 0;\n        for (const a of this.providers) {\n            let am = 0;\n            for (const b of a.messages) {\n                if (b.notDeleted) {\n                    am++;\n                }\n            }\n            await this.adapter.library.writedp(\n                `${a.name}.activeWarnings`,\n                am,\n                definitionen.genericStateObjects.activeWarnings,\n            );\n            this.activeMessages += am;\n        }\n\n        if (this.pushOn) {\n            for (const push of this.notificationServices) {\n                await push.sendMessage(this.providers, ['new', 'remove', 'all', 'removeAll']);\n            }\n        }\n        this.pushOn = true;\n        await this.adapter.library.writedp(\n            `${this.name}.activeWarnings`,\n            this.activeMessages,\n            definitionen.genericStateObjects.activeWarnings,\n        );\n        this.providers.forEach(a => a.clearMessages());\n        this.providers.forEach(a => a.finishTurn());\n        await this.library.garbageColleting(`${this.name}.activeWarnings_json`, 15_000);\n        this.log.debug(`We have ${this.activeMessages} active messages.`);\n    }\n    /**\n     * Returns true if there are providers.\n     *\n     * @returns If there are providers.\n     */\n    providersExist(): boolean {\n        return this.providers.length > 0;\n    }\n    /**\n     * Sets the connection status.\n     *\n     * @param status - the status to set, defaults to the current status\n     * @returns a promise that resolves when the status is set\n     */\n    async setConnected(status: boolean = this.connection): Promise<void> {\n        await this.adapter.library.writedp(\n            `info.connection`,\n            !!status,\n            definitionen.genericStateObjects.info.connection,\n        );\n    }\n\n    /**\n     * Handles the state push command for sending messages.\n     *\n     * This function listens for changes in the state that include the command\n     * 'commands.send_message.'. If such a command is detected, it attempts to\n     * send a message through the appropriate notification service.\n     *\n     * @param id - The identifier of the state change event.\n     * @returns A promise that resolves to a boolean indicating whether the\n     *          message was successfully sent through a notification service.\n     */\n    async onStatePush(id: string): Promise<boolean> {\n        if (!id.includes('commands.send_message.')) {\n            return false;\n        }\n        id = id.replace(`${this.adapter.namespace}.`, '');\n        const cmd = id.split('.').pop() as NotificationType.Type;\n        const service = id.split('.').slice(0, -3).join('.');\n        let index = -1;\n        let providers = [];\n        if ((index = this.providers.findIndex(a => a.name == service)) > -1) {\n            providers.push(this.providers[index]);\n        } else {\n            providers = this.providers;\n        }\n        let result = false;\n        for (const push of this.notificationServices) {\n            if (cmd == push.name && push.canManual()) {\n                await push.sendMessage(providers, [...NotificationType.manual, 'removeAll'], true);\n                await this.library.writedp(id, false);\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Completes the initialization process by writing the state objects for commands.\n     *\n     * This function writes the commands channel and device objects, and sets up the\n     * send_message state objects for each notification service. Then, it subscribes to\n     * the commands state objects and cleans up any state objects that should not exist.\n     *\n     * @returns A promise that resolves when initialization is complete.\n     */\n    async finishInit(): Promise<void> {\n        for (const p of [...this.providers, this]) {\n            const channel = `${\n                p instanceof BaseProvider ? `${this.adapter.namespace}.${p.name}` : `${this.adapter.namespace}`\n            }.commands`;\n            const commandChannel = `${channel}.send_message`;\n\n            await this.library.writedp(\n                channel,\n                undefined,\n                definitionen.statesObjectsWarnings.allService.commands._channel,\n            );\n\n            await this.library.writedp(\n                commandChannel,\n                undefined,\n                definitionen.statesObjectsWarnings.allService.commands.send_message._channel,\n            );\n            await this.library.writedp(\n                `${channel}.clearHistory`,\n                false,\n                definitionen.statesObjectsWarnings.allService.commands.clearHistory,\n            );\n\n            const states = this.library.getStates(`${commandChannel}.*`.replace('.', '\\\\.'));\n            states[`${commandChannel}`] = undefined;\n            for (const n of this.notificationServices) {\n                if (n.options.notifications.findIndex(a => NotificationType.manual.indexOf(a) != -1) == -1) {\n                    continue;\n                }\n                if (!(p instanceof BaseProvider) || n.options.service.indexOf(p.service) != -1) {\n                    const dp = `${commandChannel}.${n.name}`;\n                    states[dp] = undefined;\n                    await this.library.writedp(\n                        dp,\n                        false,\n                        definitionen.statesObjectsWarnings.allService.commands.send_message[\n                            n.name as NotificationType.Type\n                        ],\n                    );\n                }\n            }\n            for (const dp in states) {\n                if (states[dp] !== undefined) {\n                    await this.adapter.delObjectAsync(dp);\n                    this.log.debug(`Remove state ${dp}`);\n                }\n            }\n            await this.adapter.subscribeStatesAsync(`${channel}.*`);\n        }\n    }\n\n    /**\n     * Handles the clearHistory command for sending messages.\n     *\n     * This function listens for changes in the state that include the command\n     * 'commands.send_message.'. If such a command is detected, it attempts to\n     * send a message through the appropriate notification service.\n     *\n     * @param id - The identifier of the state change event.\n     * @returns A promise that resolves to a boolean indicating whether the\n     *          message was successfully sent through a notification service.\n     */\n    async clearHistory(id: string): Promise<boolean> {\n        if (!id.endsWith('.clearHistory')) {\n            return false;\n        }\n        let targets: any[] = [];\n        this.providers.forEach(a => {\n            if (id.includes(a.name)) {\n                targets.push(a);\n            }\n        });\n        if (targets.length == 0) {\n            targets = [...this.providers, this];\n        }\n        let result = false;\n        for (const a of targets) {\n            try {\n                const dp = `${a.name}.history`;\n                await this.adapter.library.writedp(dp, '[]', definitionen.genericStateObjects.history);\n                result = true;\n            } catch (error: any) {\n                this.log.error(error);\n            }\n        }\n        if (result) {\n            await this.library.writedp(id.replace(`${this.adapter.namespace}.`, ''), false);\n        }\n        return result;\n    }\n\n    /**\n     * Set the forbidden directories for the library. This method is used to prevent certain states from being written to the database.\n     *\n     * @param allowedDirs - An object with the provider name as key and a boolean value for each datapoint category (warning, alerts, messages, formatedKeys).\n     *                     If the value is false, the corresponding datapoints will be forbidden.\n     */\n    setAllowedDirs(allowedDirs: any): void {\n        const dirs = [];\n        for (const a in allowedDirs) {\n            if (allowedDirs[a] === undefined) {\n                continue;\n            }\n            if (!allowedDirs[a].dpWarning) {\n                dirs.push(`^provider\\\\.${a.replace(`Service`, ``)}\\\\.[a-zA-Z0-9-_]+\\\\.warning`);\n            }\n            if (!allowedDirs[a].dpAlerts) {\n                dirs.push(`^provider\\\\.${a.replace(`Service`, ``)}\\\\.[a-zA-Z0-9-_]+\\\\.alerts`);\n            }\n            /*if (!allowedDirs[a].dpMessage)\n                dirs.push(`^provider\\\\.${a.replace(`Service`, ``)}\\\\.[a-zA-Z0-9-_]+\\\\.messages`);*/\n            if (!allowedDirs[a].dpFormated) {\n                dirs.push(`^provider\\\\.${a.replace(`Service`, ``)}\\\\.[a-zA-Z0-9-_]+\\\\.formatedKeys`);\n            }\n\n            this.library.setForbiddenDirs(dirs);\n        }\n    }\n    /**\n     * Updates formatted data and writes formatted keys for messages across all providers.\n     *\n     * Iterates over each provider's messages and updates their formatted data.\n     * Also writes the formatted keys for each message up to the configured\n     * maximum number of raw warnings.\n     *\n     * @returns A promise that resolves when the messages have been updated.\n     */\n    async updateMesssages(): Promise<void> {\n        for (const a of this.providers) {\n            for (let b = 0; b < a.messages.length && b < this.adapter.config.numOfRawWarnings; b++) {\n                await a.messages[b].updateFormatedData();\n                await a.messages[b].writeFormatedKeys(Number(b));\n            }\n        }\n    }\n    /**\n     * Sets the speak allowed state based on the provided identifier or silent time profile.\n     *\n     * If an ID is provided, it updates the speak state for that ID if it exists in actionStates.\n     * If the ID's onlyAck property is true, the function returns immediately after writing the state.\n     *\n     * If no ID is provided or the silent time is in automatic mode, it checks the current time and\n     * day against the configured silent time profiles to determine if speaking is allowed.\n     * Updates the state if the allowed status has changed.\n     *\n     * @param id - (Optional) The identifier for the speak state to be updated.\n     * @returns A promise that resolves to true if the operation is successful.\n     */\n    async setSpeakAllowed(id: string = ''): Promise<boolean> {\n        if (id !== '') {\n            id = id.replace(`${this.adapter.namespace}.`, '');\n            if (definitionen.actionStates[id] === undefined) {\n                return false;\n            }\n            this.log.debug(`Set speak ${id.split('.').slice(-1).join('.')} to ${this.library.readdp(id)!.val}`);\n            await this.library.writedp(id, this.library.readdp(id)!.val);\n            if (definitionen.actionStates[id].onlyAck) {\n                return true;\n            }\n        }\n        if (this.isSilentAuto()) {\n            const profil = this.getSpeakProfil();\n            let isSpeakAllowed = true;\n\n            if (\n                this.silentTime !== undefined &&\n                this.silentTime.profil[profil] &&\n                Array.isArray(this.silentTime.profil[profil])\n            ) {\n                const now = new Date().getHours() + new Date().getMinutes() / 60;\n                const day = String(new Date().getDay());\n                for (const t of this.silentTime.profil[profil]) {\n                    if (t === null) {\n                        continue;\n                    }\n                    if (t.day.indexOf(day) == -1) {\n                        continue;\n                    }\n                    if (t.start < t.end) {\n                        if (t.start <= now && t.end > now) {\n                            isSpeakAllowed = false;\n                            break;\n                        }\n                    } else {\n                        if (t.start <= now || t.end > now) {\n                            isSpeakAllowed = false;\n                            break;\n                        }\n                    }\n                    isSpeakAllowed = true;\n                }\n            }\n            if (isSpeakAllowed !== this.silentTime.shouldSpeakAllowed) {\n                await this.library.writedp(\n                    `commands.silentTime.isSpeakAllowed`,\n                    isSpeakAllowed,\n                    definitionen.statesObjectsWarnings.allService.commands.silentTime.isSpeakAllowed,\n                );\n                this.silentTime.shouldSpeakAllowed = isSpeakAllowed;\n            }\n        } else {\n            this.silentTime.shouldSpeakAllowed = undefined;\n        }\n        return true;\n    }\n    /**\n     * Returns true if the silent time is in automatic mode, false otherwise.\n     *\n     * In automatic mode, the adapter will check the current time and day against the configured silent time profiles\n     * to determine if speaking is allowed. If not in automatic mode, the adapter will not check the silent time profiles\n     * and will allow speaking if the silent time commands are not defined.\n     *\n     * @returns true if the silent time is in automatic mode, false otherwise.\n     */\n    isSilentAuto(): boolean {\n        const result = this.library.readdp(`commands.silentTime.autoMode`);\n        return result != undefined && !!result.val;\n    }\n    /**\n     * Returns true if speaking is allowed, false otherwise.\n     *\n     * This method reads the value of the `commands.silentTime.isSpeakAllowed` state and returns its value.\n     * If the state is not defined, it returns true, meaning that speaking is allowed.\n     *\n     * @returns true if speaking is allowed, false otherwise.\n     */\n    isSpeakAllowed(): boolean {\n        const result = this.library.readdp(`commands.silentTime.isSpeakAllowed`);\n        return (result != undefined && !!result.val) || result == undefined;\n    }\n    /**\n     * Returns the currently active speak profile.\n     *\n     * This method reads the value of the `commands.silentTime.profil` state and returns its value.\n     * If the state is not defined or is not a number, it returns 0.\n     *\n     * @returns the currently active speak profile.\n     */\n    getSpeakProfil(): number {\n        const result = this.library.readdp(`commands.silentTime.profil`);\n        return result != undefined && typeof result.val == 'number' ? result.val : 0;\n    }\n}\n"],
  "mappings": "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",
  "names": ["reply", "b", "a"]
}
